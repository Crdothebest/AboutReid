# encoding: utf-8
"""
@author:  liaoxingyu
@contact: liaoxingyu2@jd.com
"""
# 代码主要实现了 DukeMTMC-reID 数据集的下载、检查、处理和统计

import glob          # 文件路径匹配，支持通配符
import re            # 正则表达式，用于解析图片文件名提取信息
import urllib        # 下载数据
import zipfile       # 解压缩文件
import os.path as osp  # 文件路径操作

from utils.iotools import mkdir_if_missing  # 如果目录不存在则创建
from .bases import BaseImageDataset         # 继承基类，提供统计与基础功能


class DukeMTMCreID(BaseImageDataset):
    """
    DukeMTMC-reID
    Reference:
    1. Ristani et al. Performance Measures and a Data Set for Multi-Target, Multi-Camera Tracking. ECCVW 2016.
    2. Zheng et al. Unlabeled Samples Generated by GAN Improve the Person Re-identification Baseline in vitro. ICCV 2017.
    URL: https://github.com/layumi/DukeMTMC-reID_evaluation

    Dataset statistics:
    # identities: 1404 (train + query)
    # images:16522 (train) + 2228 (query) + 17661 (gallery)
    # cameras: 8
    """
    dataset_dir = 'dukemtmcreid'

    def __init__(self, root='', verbose=True, pid_begin=0, **kwargs):
        super(DukeMTMCreID, self).__init__()
        # 数据集路径设置
        self.dataset_dir = osp.join(root, self.dataset_dir)
        self.dataset_url = 'http://vision.cs.duke.edu/DukeMTMC/data/misc/DukeMTMC-reID.zip'
        self.train_dir = osp.join(self.dataset_dir, 'bounding_box_train')
        self.query_dir = osp.join(self.dataset_dir, 'query')
        self.gallery_dir = osp.join(self.dataset_dir, 'bounding_box_test')
        self.pid_begin = pid_begin  # 设置 pid 起始编号

        # 下载数据集
        self._download_data()
        # 检查路径是否完整
        self._check_before_run()

        # 处理每个数据子集
        train = self._process_dir(self.train_dir, relabel=True)
        query = self._process_dir(self.query_dir, relabel=False)
        gallery = self._process_dir(self.gallery_dir, relabel=False)

        # 打印统计信息
        if verbose:
            print("=> DukeMTMC-reID loaded")
            self.print_dataset_statistics(train, query, gallery)

        # 保存处理后的数据
        self.train = train
        self.query = query
        self.gallery = gallery

        # 分别统计 train/query/gallery 的 ID、图像数、摄像头数、视角数
        self.num_train_pids, self.num_train_imgs, self.num_train_cams, self.num_train_vids = self.get_imagedata_info(
            self.train)
        self.num_query_pids, self.num_query_imgs, self.num_query_cams, self.num_query_vids = self.get_imagedata_info(
            self.query)
        self.num_gallery_pids, self.num_gallery_imgs, self.num_gallery_cams, self.num_gallery_vids = self.get_imagedata_info(
            self.gallery)

    def _download_data(self):
        # 如果已存在数据集目录，直接返回
        if osp.exists(self.dataset_dir):
            print("This dataset has been downloaded.")
            return

        # 创建数据集目录
        print("Creating directory {}".format(self.dataset_dir))
        mkdir_if_missing(self.dataset_dir)

        # 下载压缩文件到指定路径
        fpath = osp.join(self.dataset_dir, osp.basename(self.dataset_url))
        print("Downloading DukeMTMC-reID dataset")
        urllib.request.urlretrieve(self.dataset_url, fpath)

        # 解压缩
        print("Extracting files")
        zip_ref = zipfile.ZipFile(fpath, 'r')
        zip_ref.extractall(self.dataset_dir)
        zip_ref.close()

    def _check_before_run(self):
        """运行前检查路径完整性"""
        if not osp.exists(self.dataset_dir):
            raise RuntimeError("'{}' is not available".format(self.dataset_dir))
        if not osp.exists(self.train_dir):
            raise RuntimeError("'{}' is not available".format(self.train_dir))
        if not osp.exists(self.query_dir):
            raise RuntimeError("'{}' is not available".format(self.query_dir))
        if not osp.exists(self.gallery_dir):
            raise RuntimeError("'{}' is not available".format(self.gallery_dir))

    def _process_dir(self, dir_path, relabel=False):
        # 读取目录下所有 jpg 图片路径
        img_paths = glob.glob(osp.join(dir_path, '*.jpg'))

        # 文件名格式: '0002_c1_f0046182.jpg'
        # 其中 0002 表示 pid，c1 表示摄像头编号
        pattern = re.compile(r'([-\d]+)_c(\d)')

        # 提取 pid，建立去重后的 pid 容器
        pid_container = set()
        for img_path in img_paths:
            pid, _ = map(int, pattern.search(img_path).groups())
            pid_container.add(pid)

        # pid -> label 映射，label 从 0 开始
        pid2label = {pid: label for label, pid in enumerate(pid_container)}

        dataset = []
        cam_container = set()
        for img_path in img_paths:
            pid, camid = map(int, pattern.search(img_path).groups())
            assert 1 <= camid <= 8  # 摄像头编号在 1~8 之间
            camid -= 1  # 变为从 0 开始
            if relabel:
                pid = pid2label[pid]  # 如果需要重新标号，替换为新 label
            # 每张图存成 (路径, pid, 摄像头id, 轨迹id)
            dataset.append((img_path, self.pid_begin + pid, camid, 1))
            cam_container.add(camid)

        print(cam_container, 'cam_container')  # 打印所有摄像头编号
        return dataset

